


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > UserServiceTest</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.sharewrap.sharewrap_backend.services</a>
</div>

<h1>Coverage Summary for Class: UserServiceTest (com.sharewrap.sharewrap_backend.services)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">UserServiceTest</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (33/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (9/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98%
  </span>
  <span class="absValue">
    (348/355)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.sharewrap.sharewrap_backend.services;
&nbsp;
&nbsp;import com.sharewrap.sharewrap_backend.dtos.LoginDto;
&nbsp;import com.sharewrap.sharewrap_backend.dtos.PromptpayDto;
&nbsp;import com.sharewrap.sharewrap_backend.dtos.RegisterDto;
&nbsp;import com.sharewrap.sharewrap_backend.dtos.UserDto;
&nbsp;import com.sharewrap.sharewrap_backend.exceptions.AppException;
&nbsp;import com.sharewrap.sharewrap_backend.exceptions.UserExceptionHandler;
&nbsp;import com.sharewrap.sharewrap_backend.exceptions.UserExceptionHandlerTests;
&nbsp;import com.sharewrap.sharewrap_backend.mappers.PromptpayMapper;
&nbsp;import com.sharewrap.sharewrap_backend.mappers.UserMapper;
&nbsp;import com.sharewrap.sharewrap_backend.models.Bill;
&nbsp;import com.sharewrap.sharewrap_backend.models.Promptpay;
&nbsp;import com.sharewrap.sharewrap_backend.models.User;
&nbsp;import com.sharewrap.sharewrap_backend.repositories.BillRepository;
&nbsp;import com.sharewrap.sharewrap_backend.repositories.PromptpayRepository;
&nbsp;import com.sharewrap.sharewrap_backend.repositories.UserRepository;
&nbsp;import org.junit.jupiter.api.Test;
&nbsp;import org.mockito.Mockito;
&nbsp;import org.springframework.core.MethodParameter;
&nbsp;import org.springframework.http.HttpStatus;
&nbsp;import org.springframework.http.ResponseEntity;
&nbsp;import org.springframework.security.crypto.password.PasswordEncoder;
&nbsp;import org.springframework.validation.BindingResult;
&nbsp;import org.springframework.web.bind.MethodArgumentNotValidException;
&nbsp;
&nbsp;import java.io.ByteArrayOutputStream;
&nbsp;import java.io.PrintStream;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static org.junit.jupiter.api.Assertions.*;
&nbsp;import static org.mockito.Mockito.*;
&nbsp;
<b class="fc">&nbsp;public class UserServiceTest {</b>
&nbsp;    // Test case 1 - login
&nbsp;    // Test case 1 - login interface based (T1)
&nbsp;    @Test
&nbsp;    public void test_valid_login_credentials_print_logging_in() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
<b class="fc">&nbsp;        boolean result = false;</b>
<b class="fc">&nbsp;        LoginDto loginDto = new LoginDto(&quot;test@example.com&quot;, &quot;password&quot;.toCharArray());</b>
<b class="fc">&nbsp;        User user = new User(&quot;test@example.com&quot;, &quot;test&quot;);</b>
<b class="fc">&nbsp;        user.setPassword(&quot;password&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        when(userRepository.findByEmail(loginDto.getEmail())).thenReturn(Optional.of(user));</b>
<b class="fc">&nbsp;        when(passwordEncoder.matches(Mockito.any(CharSequence.class), Mockito.anyString())).thenReturn(true);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;
<b class="fc">&nbsp;        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</b>
<b class="fc">&nbsp;        System.setOut(new PrintStream(outputStream));</b>
&nbsp;
<b class="fc">&nbsp;        userService.login(loginDto);</b>
&nbsp;
<b class="pc">&nbsp;        if(&quot;logging  in...&quot;.equals(outputStream.toString().trim())){</b>
<b class="fc">&nbsp;            result = true;</b>
&nbsp;        }
<b class="fc">&nbsp;        assertTrue(result);</b>
&nbsp;    }
&nbsp;    // Test case 1 - login interface based (T2)
&nbsp;    @Test
&nbsp;    public void test_valid_login_with_invalid_password() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
<b class="fc">&nbsp;        boolean result = true;</b>
<b class="fc">&nbsp;        LoginDto loginDto = new LoginDto(&quot;test@example.com&quot;, &quot;wrongpassword&quot;.toCharArray());</b>
<b class="fc">&nbsp;        User user = new User(&quot;test@example.com&quot;, &quot;test&quot;);</b>
<b class="fc">&nbsp;        user.setPassword(&quot;password&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        when(userRepository.findByEmail(loginDto.getEmail())).thenReturn(Optional.of(user));</b>
<b class="fc">&nbsp;        when(passwordEncoder.matches(Mockito.any(CharSequence.class), Mockito.anyString())).thenReturn(false);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            userService.login(loginDto);</b>
<b class="nc">&nbsp;            fail(&quot;Expected AppException to be thrown&quot;);</b>
<b class="fc">&nbsp;        } catch (AppException e) {</b>
<b class="pc">&nbsp;            if (HttpStatus.BAD_REQUEST == e.getStatus() &amp;&amp; &quot;Invalid password&quot; == e.getMessage()){</b>
<b class="fc">&nbsp;                result = false;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;        assertFalse(result);</b>
&nbsp;    }
&nbsp;    // Test case 1 - login interface based (T3)
&nbsp;    @Test
&nbsp;    public void test_valid_login_with_invalid_email() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
<b class="fc">&nbsp;        boolean result = true;</b>
<b class="fc">&nbsp;        LoginDto loginDto = new LoginDto(&quot;&quot;, &quot;password&quot;.toCharArray());</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;
<b class="fc">&nbsp;        AppException exception = assertThrows(AppException.class, () -&gt; userService.login(loginDto));</b>
<b class="pc">&nbsp;        if(HttpStatus.NOT_FOUND == exception.getStatus()) {</b>
<b class="fc">&nbsp;            result = false;</b>
&nbsp;        }
<b class="fc">&nbsp;        assertFalse(result);</b>
&nbsp;    }
&nbsp;    // Test case 1 - login interface based (T4)
&nbsp;    @Test
&nbsp;    public void test_valid_login_with_invalid_email_invalid_password() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
<b class="fc">&nbsp;        boolean result = true;</b>
<b class="fc">&nbsp;        LoginDto loginDto = new LoginDto(&quot;&quot;, &quot;wrongpassword&quot;.toCharArray());</b>
<b class="fc">&nbsp;        User user = new User(&quot;test@example.com&quot;, &quot;test&quot;);</b>
<b class="fc">&nbsp;        user.setPassword(&quot;password&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        when(userRepository.findByEmail(loginDto.getEmail())).thenReturn(Optional.of(user));</b>
<b class="fc">&nbsp;        when(passwordEncoder.matches(Mockito.any(CharSequence.class), Mockito.anyString())).thenReturn(false);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;
<b class="fc">&nbsp;        AppException exception = assertThrows(AppException.class, () -&gt; userService.login(loginDto));</b>
<b class="pc">&nbsp;        if(HttpStatus.BAD_REQUEST == exception.getStatus()){</b>
<b class="fc">&nbsp;            result = false;</b>
&nbsp;        }
<b class="fc">&nbsp;        assertFalse(result);</b>
&nbsp;    }
&nbsp;    // Test case 1 - login functionality based
&nbsp;    // Test case 1 - login functionality based (T1)
&nbsp;    @Test
&nbsp;    public void test_valid_login_func() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        LoginDto loginDto = new LoginDto(&quot;test@example.com&quot;, &quot;password&quot;.toCharArray());</b>
<b class="fc">&nbsp;        User user = new User(&quot;test@example.com&quot;, &quot;test&quot;);</b>
<b class="fc">&nbsp;        user.setPassword(&quot;password&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        when(userRepository.findByEmail(loginDto.getEmail())).thenReturn(Optional.of(user));</b>
<b class="fc">&nbsp;        when(passwordEncoder.matches(Mockito.any(CharSequence.class), Mockito.anyString())).thenReturn(true);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;
<b class="fc">&nbsp;        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</b>
<b class="fc">&nbsp;        System.setOut(new PrintStream(outputStream));</b>
&nbsp;
<b class="fc">&nbsp;        userService.login(loginDto);</b>
&nbsp;
<b class="fc">&nbsp;        assertEquals(&quot;logging  in...&quot;, outputStream.toString().trim());</b>
&nbsp;    }
&nbsp;    // Test case 1 - login functionality based (T2)
&nbsp;    @Test
&nbsp;    public void test_valid_login_func_with_invalid_password() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        LoginDto loginDto = new LoginDto(&quot;test@example.com&quot;, &quot;wrongpassword&quot;.toCharArray());</b>
<b class="fc">&nbsp;        User user = new User(&quot;test@example.com&quot;, &quot;test&quot;);</b>
<b class="fc">&nbsp;        user.setPassword(&quot;password&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        when(userRepository.findByEmail(loginDto.getEmail())).thenReturn(Optional.of(user));</b>
<b class="fc">&nbsp;        when(passwordEncoder.matches(Mockito.any(CharSequence.class), Mockito.anyString())).thenReturn(false);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            userService.login(loginDto);</b>
<b class="nc">&nbsp;            fail(&quot;Expected AppException to be thrown&quot;);</b>
<b class="fc">&nbsp;        } catch (AppException e) {</b>
<b class="fc">&nbsp;            assertEquals(HttpStatus.BAD_REQUEST, e.getStatus());</b>
<b class="fc">&nbsp;            assertEquals(&quot;Invalid password&quot;, e.getMessage());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;    // Test case 1 - login login functionality based (T3)
&nbsp;    @Test
&nbsp;    public void test_valid_login_func_with_invalid_email() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        LoginDto loginDto = new LoginDto(&quot;&quot;, &quot;password&quot;.toCharArray());</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;
<b class="fc">&nbsp;        AppException exception = assertThrows(AppException.class, () -&gt; userService.login(loginDto));</b>
<b class="fc">&nbsp;        assertEquals(HttpStatus.NOT_FOUND, exception.getStatus());</b>
&nbsp;    }
&nbsp;    // Test case 1 - login functionality based (T4)
&nbsp;    @Test
&nbsp;    public void test_valid_login_func_with_invalid_email_invalid_password() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
<b class="fc">&nbsp;        boolean result = false;</b>
<b class="fc">&nbsp;        LoginDto loginDto = new LoginDto(&quot;&quot;, &quot;wrongpassword&quot;.toCharArray());</b>
<b class="fc">&nbsp;        User user = new User(&quot;test@example.com&quot;, &quot;test&quot;);</b>
<b class="fc">&nbsp;        user.setPassword(&quot;password&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        when(userRepository.findByEmail(loginDto.getEmail())).thenReturn(Optional.of(user));</b>
<b class="fc">&nbsp;        when(passwordEncoder.matches(Mockito.any(CharSequence.class), Mockito.anyString())).thenReturn(false);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;
<b class="fc">&nbsp;        AppException exception = assertThrows(AppException.class, () -&gt; userService.login(loginDto));</b>
<b class="fc">&nbsp;        assertEquals(HttpStatus.BAD_REQUEST, exception.getStatus());</b>
&nbsp;    }
&nbsp;
&nbsp;    // Test case 2 - generateUniqueUserId
&nbsp;    // Test case 2 - generateUniqueUserId interface based (T1)
&nbsp;    @Test
&nbsp;    public void test_generateUniqueUserId_uniqueUsername1() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        Mockito.when(userRepository.existsById(Mockito.anyString())).thenReturn(false);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String username = &quot;john_doe&quot;;</b>
<b class="fc">&nbsp;        String userId = userService.generateUniqueUserId(username);</b>
<b class="pc">&nbsp;        assertFalse(username.length()+3 == userId.length());</b>
&nbsp;    }
&nbsp;    // Test case 2 - generateUniqueUserId interface based (T2)
&nbsp;    @Test
&nbsp;    public void test_generateUniqueUserId_uniqueUsername2() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        Mockito.when(userRepository.existsById(Mockito.anyString())).thenReturn(false);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String username = &quot;john_doe&quot;;</b>
<b class="fc">&nbsp;        String userId = userService.generateUniqueUserId(username);</b>
<b class="pc">&nbsp;        assertTrue(username.length()+6 == userId.length());</b>
&nbsp;    }
&nbsp;    // Test case 2 - generateUniqueUserId interface based (T3)
&nbsp;    @Test
&nbsp;    public void test_generateUniqueUserId_uniqueUsername3() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        Mockito.when(userRepository.existsById(Mockito.anyString())).thenReturn(false);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String username = &quot;john_doe&quot;;</b>
<b class="fc">&nbsp;        String userId = userService.generateUniqueUserId(username);</b>
<b class="pc">&nbsp;        assertFalse(username.length()+8 == userId.length());</b>
&nbsp;    }
&nbsp;    // Test case 2 - generateUniquesUserId functionality based (T1)
&nbsp;    @Test
&nbsp;    public void test_generateUniqueUserId_differentUsernames() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String username1 = &quot;john_doe&quot;;</b>
<b class="fc">&nbsp;        String username2 = &quot;jane_smith&quot;;</b>
&nbsp;
<b class="fc">&nbsp;        String userId1 = userService.generateUniqueUserId(username1);</b>
<b class="fc">&nbsp;        String userId2 = userService.generateUniqueUserId(username2);</b>
&nbsp;
<b class="fc">&nbsp;        assertNotEquals(userId1, userId2);</b>
&nbsp;    }
&nbsp;    // Test case 2 - generateUniquesUserId functionality based (T2)
&nbsp;    @Test
&nbsp;    public void test_generateUniqueUserId_sameUsernames() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String username1 = &quot;john_doe&quot;;</b>
<b class="fc">&nbsp;        String username2 = &quot;john_doe&quot;;</b>
&nbsp;
<b class="fc">&nbsp;        String userId1 = userService.generateUniqueUserId(username1);</b>
<b class="fc">&nbsp;        String userId2 = userService.generateUniqueUserId(username2);</b>
<b class="fc">&nbsp;        assertNotEquals(userId1, userId2);</b>
&nbsp;    }
&nbsp;    // Test case 3 - generateUserId
&nbsp;    // Test case 3 - generateUserId interface based (T1)
&nbsp;    @Test
&nbsp;    public void test_getUser_exist() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String validUserId = &quot;validUserId&quot;;</b>
<b class="fc">&nbsp;        boolean ans = false;</b>
<b class="fc">&nbsp;        User user = new User();</b>
<b class="fc">&nbsp;        user.setId(validUserId);</b>
<b class="fc">&nbsp;        when(userRepository.findById(validUserId)).thenReturn(Optional.of(user));</b>
<b class="fc">&nbsp;        when(userMapper.toUserDto(any(User.class)))</b>
<b class="fc">&nbsp;                .thenAnswer(invocation -&gt; {</b>
<b class="fc">&nbsp;                    User userArgument = invocation.getArgument(0);</b>
<b class="fc">&nbsp;                    UserDto userDto = new UserDto();</b>
<b class="fc">&nbsp;                    userDto.setId(userArgument.getId());</b>
<b class="fc">&nbsp;                    return userDto;</b>
&nbsp;                });
&nbsp;        // Act
<b class="fc">&nbsp;        UserDto result = userService.getUser(validUserId);</b>
&nbsp;
&nbsp;        // Assert
<b class="fc">&nbsp;        assertNotNull(result);</b>
<b class="pc">&nbsp;        if (validUserId.equals(result.getId())) {</b>
<b class="fc">&nbsp;            ans = true;</b>
&nbsp;        }
<b class="fc">&nbsp;        assertTrue(ans);</b>
&nbsp;    }
&nbsp;    // Test case 3 - generateUserId interface based (T2)
&nbsp;    @Test
&nbsp;    public void test_getUser_not_found() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
<b class="fc">&nbsp;        boolean ans = true;</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String invalidUserId = &quot;invalidUserId&quot;;</b>
<b class="fc">&nbsp;        when(userRepository.findById(invalidUserId)).thenReturn(Optional.empty());</b>
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            userService.getUser(invalidUserId);</b>
<b class="fc">&nbsp;        } catch (AppException e) {</b>
<b class="fc">&nbsp;            ans = false;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // Assert
<b class="fc">&nbsp;        assertFalse(ans);</b>
&nbsp;    }
&nbsp;    // Test case 3 - generateUserId functionality based (T1)
&nbsp;    @Test
&nbsp;    public void test_valid_userId() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String validUserId = &quot;validUserId&quot;;</b>
&nbsp;
<b class="fc">&nbsp;        User user = new User();</b>
<b class="fc">&nbsp;        user.setId(validUserId);</b>
<b class="fc">&nbsp;        when(userRepository.findById(validUserId)).thenReturn(Optional.of(user));</b>
<b class="fc">&nbsp;        when(userMapper.toUserDto(any(User.class)))</b>
<b class="fc">&nbsp;                .thenAnswer(invocation -&gt; {</b>
<b class="fc">&nbsp;                    User userArgument = invocation.getArgument(0);</b>
<b class="fc">&nbsp;                    UserDto userDto = new UserDto();</b>
<b class="fc">&nbsp;                    userDto.setId(userArgument.getId());</b>
<b class="fc">&nbsp;                    return userDto;</b>
&nbsp;                });
&nbsp;        // Act
<b class="fc">&nbsp;        UserDto result = userService.getUser(validUserId);</b>
&nbsp;
&nbsp;        // Assert
<b class="fc">&nbsp;        assertNotNull(result);</b>
<b class="fc">&nbsp;        assertEquals(validUserId, result.getId());</b>
&nbsp;    }
&nbsp;    // Test case 3 - generateUserId functionality based (T2)
&nbsp;    @Test
&nbsp;    public void test_getUser_not_found_func() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
&nbsp;        // Arrange
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String invalidUserId = &quot;invalidUserId&quot;;</b>
<b class="fc">&nbsp;        when(userRepository.findById(invalidUserId)).thenReturn(Optional.empty());</b>
&nbsp;
&nbsp;        // Act
<b class="fc">&nbsp;        assertThrows(AppException.class, () -&gt; userService.getUser(invalidUserId));</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    //Other tests
&nbsp;    @Test
&nbsp;    public void test_unknown_email() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String email = &quot;unknown@example.com&quot;;</b>
<b class="fc">&nbsp;        when(userRepository.findByEmail(email)).thenReturn(Optional.empty());</b>
&nbsp;
&nbsp;        // Act and Assert
<b class="fc">&nbsp;        AppException exception = assertThrows(AppException.class, () -&gt; userService.findByEmail(email));</b>
<b class="fc">&nbsp;        assertEquals(HttpStatus.NOT_FOUND, exception.getStatus());</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    public void test_generateUserId_length() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String username = &quot;john_doe&quot;;</b>
<b class="fc">&nbsp;        String result = userService.generateUserId(username);</b>
<b class="fc">&nbsp;        assertEquals(username.length() + 6, result.length());</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    public void test_generateUserId_length1() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String username = &quot;&quot;;</b>
<b class="fc">&nbsp;        String result = userService.generateUserId(username);</b>
<b class="fc">&nbsp;        assertEquals(username.length() + 6, result.length());</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    public void test_generateUserId_oneCharacter() {
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String username = &quot;a&quot;;</b>
<b class="fc">&nbsp;        String result = userService.generateUserId(username);</b>
<b class="fc">&nbsp;        assertEquals(7, result.length());</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    public void test_register_null_email() {
&nbsp;        // Arrange
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;
<b class="fc">&nbsp;        RegisterDto userDto = new RegisterDto(null, &quot;testuser&quot;, &quot;password&quot;.toCharArray());</b>
&nbsp;
&nbsp;        // Act and Assert
<b class="fc">&nbsp;        assertThrows(NullPointerException.class, () -&gt; userService.register(userDto));</b>
<b class="fc">&nbsp;        verify(userRepository, never()).findByEmail(anyString());</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    public void test_register_existing_email() {
&nbsp;        // Arrange
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        RegisterDto userDto = new RegisterDto(&quot;test@example.com&quot;, &quot;testuser&quot;, &quot;password&quot;.toCharArray());</b>
<b class="fc">&nbsp;        User existingUser = new User(&quot;test@example.com&quot;, &quot;existinguser&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        when(userRepository.findByEmail(userDto.getEmail())).thenReturn(Optional.of(existingUser));</b>
&nbsp;
&nbsp;        // Act and Assert
<b class="fc">&nbsp;        assertThrows(AppException.class, () -&gt; userService.register(userDto));</b>
<b class="fc">&nbsp;        verify(userRepository).findByEmail(userDto.getEmail());</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    public void test_invalid_user_id() {
&nbsp;        // Arrange
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String userId = &quot;invalidUserId&quot;;</b>
<b class="fc">&nbsp;        Bill bill = new Bill();</b>
&nbsp;
&nbsp;        // Act and Assert
&nbsp;        try {
<b class="fc">&nbsp;            userService.addBill(userId, bill);</b>
<b class="nc">&nbsp;            fail(&quot;Expected AppException, but no exception was thrown&quot;);</b>
<b class="fc">&nbsp;        } catch (AppException e) {</b>
<b class="fc">&nbsp;            assertEquals(&quot;Unknown user&quot;, e.getMessage());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    void test_add_bills_null_user_id() {
&nbsp;        // Arrange
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String userId = null;</b>
<b class="fc">&nbsp;        List&lt;Bill&gt; billList = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        Bill bill1 = new Bill(&quot;Bill 1&quot;);</b>
<b class="fc">&nbsp;        Bill bill2 = new Bill(&quot;Bill 2&quot;);</b>
<b class="fc">&nbsp;        billList.add(bill1);</b>
<b class="fc">&nbsp;        billList.add(bill2);</b>
&nbsp;
&nbsp;        // Act and Assert
<b class="fc">&nbsp;        AppException exception = assertThrows(AppException.class, () -&gt; userService.addBills(userId, billList));</b>
<b class="fc">&nbsp;        assertEquals(&quot;Unknown user&quot;, exception.getMessage());</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    public void test_add_bills_unknown_user() {
&nbsp;        // Arrange
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;
&nbsp;        // Mock the UserRepository to return an empty optional when findById is called
<b class="fc">&nbsp;        when(userRepository.findById(&quot;user123&quot;)).thenReturn(Optional.empty());</b>
&nbsp;
<b class="fc">&nbsp;        String userId = &quot;user123&quot;;</b>
<b class="fc">&nbsp;        List&lt;Bill&gt; billList = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        Bill bill1 = new Bill(&quot;Bill 1&quot;);</b>
<b class="fc">&nbsp;        Bill bill2 = new Bill(&quot;Bill 2&quot;);</b>
<b class="fc">&nbsp;        billList.add(bill1);</b>
<b class="fc">&nbsp;        billList.add(bill2);</b>
&nbsp;
&nbsp;        // Act and Assert
<b class="fc">&nbsp;        assertThrows(AppException.class, () -&gt; userService.addBills(userId, billList));</b>
&nbsp;
&nbsp;        // Verify that findById was called with the correct user ID
<b class="fc">&nbsp;        verify(userRepository, times(1)).findById(userId);</b>
&nbsp;
&nbsp;        // Verify that no interactions happened with other mocks
<b class="fc">&nbsp;        verifyNoMoreInteractions(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    public void test_null_user_id() {
&nbsp;        // Arrange
<b class="fc">&nbsp;        String userId = null;</b>
<b class="fc">&nbsp;        String friendId = &quot;friend1&quot;;</b>
&nbsp;
<b class="fc">&nbsp;        UserRepository userRepository = mock(UserRepository.class);</b>
&nbsp;
&nbsp;        // Assuming you have a user in the repository for the friend
<b class="fc">&nbsp;        User friendUser = new User();</b>
<b class="fc">&nbsp;        when(userRepository.findById(friendId)).thenReturn(Optional.of(friendUser));</b>
&nbsp;
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, null, null, null);</b>
&nbsp;
&nbsp;        // Act and Assert
<b class="fc">&nbsp;        assertThrows(AppException.class, () -&gt; userService.deleteFriend(userId, friendId));</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    public void test_valid_username() {
&nbsp;        // Arrange
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String validUsername = &quot;john_doe&quot;;</b>
&nbsp;
&nbsp;        // Mock behavior of userRepository.findByUsername to return an empty Optional
<b class="fc">&nbsp;        when(userRepository.findByUsername(validUsername)).thenReturn(Optional.empty());</b>
&nbsp;
&nbsp;        // Act and Assert
<b class="fc">&nbsp;        AppException exception = assertThrows(AppException.class, () -&gt; userService.findByUsername(validUsername));</b>
<b class="fc">&nbsp;        assertEquals(&quot;Unknown user&quot;, exception.getMessage());</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    public void test_correct_userDto() {
&nbsp;        // Arrange
<b class="fc">&nbsp;        UserRepository userRepository = Mockito.mock(UserRepository.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = Mockito.mock(UserMapper.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = Mockito.mock(BillRepository.class);</b>
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
<b class="fc">&nbsp;        String validUsername = &quot;john_doe&quot;;</b>
<b class="fc">&nbsp;        User expectedUser = new User(&quot;john.doe@example.com&quot;, validUsername);</b>
<b class="fc">&nbsp;        UserDto expectedUserDto = new UserDto(expectedUser.getId(), expectedUser.getEmail(), expectedUser.getUsername(), &quot;&quot;);</b>
<b class="fc">&nbsp;        when(userRepository.findByUsername(validUsername)).thenReturn(Optional.of(expectedUser));</b>
&nbsp;
&nbsp;        // Act
<b class="fc">&nbsp;        UserDto result = userService.findByUsername(validUsername);</b>
&nbsp;
&nbsp;        // Assert
<b class="fc">&nbsp;        assertEquals(expectedUserDto, result);</b>
&nbsp;    }
&nbsp;    @Test
&nbsp;    public void test_valid_username_findByUsername() {
&nbsp;        // Arrange
<b class="fc">&nbsp;        UserRepository userRepository = mock(UserRepository.class);</b>
<b class="fc">&nbsp;        UserMapper userMapper = mock(UserMapper.class);</b>
<b class="fc">&nbsp;        PasswordEncoder passwordEncoder = mock(PasswordEncoder.class);</b>
<b class="fc">&nbsp;        BillRepository billRepository = mock(BillRepository.class);</b>
<b class="fc">&nbsp;        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);</b>
&nbsp;
<b class="fc">&nbsp;        String username = &quot;Unknown user&quot;;</b>
<b class="fc">&nbsp;        User user = new User();</b>
<b class="fc">&nbsp;        user.setUsername(username);</b>
<b class="fc">&nbsp;        UserDto expectedUserDto = new UserDto();</b>
&nbsp;
&nbsp;        // Define the behavior of mocks
<b class="fc">&nbsp;        when(userRepository.findByUsername(username)).thenReturn(Optional.of(user));</b>
<b class="fc">&nbsp;        when(userMapper.toUserDto(user)).thenReturn(expectedUserDto);</b>
&nbsp;
&nbsp;        // Act
<b class="fc">&nbsp;        UserDto result = userService.findByUsername(username);</b>
&nbsp;
&nbsp;        // Assert
<b class="fc">&nbsp;        assertNotNull(result);</b>
<b class="fc">&nbsp;        assertNotNull(expectedUserDto);</b>
<b class="fc">&nbsp;        assertEquals(expectedUserDto, result);</b>
&nbsp;
&nbsp;        // Verify that the expected methods were called on mocks
<b class="fc">&nbsp;        verify(userRepository).findByUsername(username);</b>
<b class="fc">&nbsp;        verify(userMapper).toUserDto(user);</b>
&nbsp;    }
&nbsp;//    @Test(expected = AppException.class)
&nbsp;//    public void test_empty_username() {
&nbsp;//        // Arrange
&nbsp;//        UserRepository userRepository = Mockito.mock(UserRepository.class);
&nbsp;//        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);
&nbsp;//        UserMapper userMapper = Mockito.mock(UserMapper.class);
&nbsp;//        BillRepository billRepository = Mockito.mock(BillRepository.class);
&nbsp;//        UserService userService = new UserService(userRepository, passwordEncoder, userMapper, billRepository);
&nbsp;//        String emptyUsername = &quot;&quot;;
&nbsp;//
&nbsp;//        // Act
&nbsp;//        userService.findByUsername(emptyUsername);
&nbsp;//    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-28 00:26</div>
</div>
</body>
</html>
